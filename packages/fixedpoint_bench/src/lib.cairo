// Generated by scripts/bench/generate_fixedpoint_bench.sh from Lean IR outputs.
// Source module: MyLeanFixedPointBench (baseline --optimize false, optimized --optimize true).
// Do not edit this file directly.
use core::integer::u256;

fn qmul_kernel_hand(a: u256, b: u256, c: u256) -> u256 {
            (((a * b) * c) + ((a * b) * c))
        }

fn qmul_kernel_opt(a: u256, b: u256, c: u256) -> u256 {
            {
                let __leancairo_internal_cse_u256: u256 = ((a * b) * c);
                (__leancairo_internal_cse_u256 + __leancairo_internal_cse_u256)
            }
        }

fn qexp_taylor_hand(x: u256) -> u256 {
            ((((x * x) * (x * x)) * ((x * x) * (x * x))) + (((x * x) * (x * x)) * ((x * x) * (x * x))))
        }

fn qexp_taylor_opt(x: u256) -> u256 {
            {
                let __leancairo_internal_cse_u256: u256 = {
                let __leancairo_internal_cse_u256: u256 = {
                let __leancairo_internal_cse_u256: u256 = {
                let __leancairo_internal_cse_u256: u256 = x;
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            };
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            };
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            };
                (__leancairo_internal_cse_u256 + __leancairo_internal_cse_u256)
            }
        }

fn qlog1p_taylor_hand(z: u256) -> u256 {
            ((((z * z) * (z * z)) - (z * z)) + (((z * z) * (z * z)) - (z * z)))
        }

fn qlog1p_taylor_opt(z: u256) -> u256 {
            {
                let __leancairo_internal_cse_u256: u256 = ({
                let __leancairo_internal_cse_u256: u256 = {
                let __leancairo_internal_cse_u256: u256 = z;
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            };
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            } - {
                let __leancairo_internal_cse_u256: u256 = z;
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            });
                (__leancairo_internal_cse_u256 + __leancairo_internal_cse_u256)
            }
        }

fn qnewton_recip_hand(x: u256) -> u256 {
            (((((x * x) * (x * x)) * x) - (x * x)) + ((((x * x) * (x * x)) * x) - (x * x)))
        }

fn qnewton_recip_opt(x: u256) -> u256 {
            {
                let __leancairo_internal_cse_u256: u256 = (({
                let __leancairo_internal_cse_u256: u256 = {
                let __leancairo_internal_cse_u256: u256 = x;
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            };
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            } * x) - {
                let __leancairo_internal_cse_u256: u256 = x;
                (__leancairo_internal_cse_u256 * __leancairo_internal_cse_u256)
            });
                (__leancairo_internal_cse_u256 + __leancairo_internal_cse_u256)
            }
        }

fn u256_from_u128(v: u128) -> u256 {
    u256 { low: v, high: 0 }
}

/// Calculate fibonacci sequence value at the nth position
///
/// This function computes the fibonacci number at position n using a recursive approach.
/// The sequence starts with the provided initial values a and b, and continues according
/// to the fibonacci rule where each number is the sum of the two preceding ones.
///
/// #### Arguments
/// * `a` - The first number in the sequence (F₀)
/// * `b` - The second number in the sequence (F₁)
/// * `n` - The position in the sequence to calculate (0-indexed)
///
/// #### Returns
/// * `felt252` - The nth number in the fibonacci sequence
pub fn fib(a: felt252, b: felt252, n: felt252) -> felt252 {
    match n {
        0 => a,
        _ => fib(b, a + b, n - 1),
    }
}

fn fib_pair_fast(n: u32) -> (felt252, felt252) {
    if n == 0 {
        (0, 1)
    } else {
        let (a, b) = fib_pair_fast(n / 2);
        let c = a * (2 * b - a);
        let d = a * a + b * b;
        if n % 2 == 0 {
            (c, d)
        } else {
            (d, c + d)
        }
    }
}

fn fib_fast(n: u32) -> felt252 {
    let (f, _) = fib_pair_fast(n);
    f
}

#[executable]
fn bench_qmul_hand() -> u256 {
    qmul_kernel_hand(u256_from_u128(17), u256_from_u128(9), u256_from_u128(5))
}

#[executable]
fn bench_qmul_opt() -> u256 {
    qmul_kernel_opt(u256_from_u128(17), u256_from_u128(9), u256_from_u128(5))
}

#[executable]
fn bench_qexp_hand() -> u256 {
    qexp_taylor_hand(u256_from_u128(11))
}

#[executable]
fn bench_qexp_opt() -> u256 {
    qexp_taylor_opt(u256_from_u128(11))
}

#[executable]
fn bench_qlog_hand() -> u256 {
    qlog1p_taylor_hand(u256_from_u128(13))
}

#[executable]
fn bench_qlog_opt() -> u256 {
    qlog1p_taylor_opt(u256_from_u128(13))
}

#[executable]
fn bench_qnewton_hand() -> u256 {
    qnewton_recip_hand(u256_from_u128(3))
}

#[executable]
fn bench_qnewton_opt() -> u256 {
    qnewton_recip_opt(u256_from_u128(3))
}

#[executable]
fn bench_fib_naive() -> felt252 {
    fib(0, 1, 200)
}

#[executable]
fn bench_fib_fast() -> felt252 {
    fib_fast(200)
}

#[cfg(test)]
mod tests {
    use super::{
        qmul_kernel_hand,
        qmul_kernel_opt,
        qexp_taylor_hand,
        qexp_taylor_opt,
        qlog1p_taylor_hand,
        qlog1p_taylor_opt,
        qnewton_recip_hand,
        qnewton_recip_opt,
        fib,
        fib_fast,
        u256_from_u128,
    };

    #[test]
    fn test_qmul_equivalence() {
        let a = u256_from_u128(17);
        let b = u256_from_u128(9);
        let c = u256_from_u128(5);
        assert_eq!(qmul_kernel_hand(a, b, c), qmul_kernel_opt(a, b, c));
    }

    #[test]
    fn test_qexp_equivalence() {
        let x = u256_from_u128(11);
        assert_eq!(qexp_taylor_hand(x), qexp_taylor_opt(x));
    }

    #[test]
    fn test_qlog_equivalence() {
        let z = u256_from_u128(13);
        assert_eq!(qlog1p_taylor_hand(z), qlog1p_taylor_opt(z));
    }

    #[test]
    fn test_qnewton_equivalence() {
        let x = u256_from_u128(3);
        assert_eq!(qnewton_recip_hand(x), qnewton_recip_opt(x));
    }

    #[test]
    fn test_fib_equivalence() {
        assert_eq!(fib(0, 1, 200), fib_fast(200));
    }
}
